\documentclass[handout]{beamer}

\input{aulas-beamer-preamble}


\title[Programação Modular]
{%
    Interfaces%
}
\author[Prof. Hugo de Paula]
{
    Prof.~Hugo~de~Paula
}
\institute[DCC / PUC Minas]
{\includegraphics[width=4cm]{puc_engesoft_logo.png} \\
    \textsc{Pontifícia Universidade Católica de Minas Gerais}\\
    Curso de Engenharia de Software
}
\date[]{}

\lstset{language=Java,
   basicstyle=\scriptsize,
   commentstyle=\color{red},
   showstringspaces=false,
   numbers=none,
   numberstyle=\tiny}

\begin{document}


\selectlanguage{brazil}

\begin{frame}
   \titlepage
\end{frame}

%\addtobeamertemplate{frametitle}{}{%
%    \begin{tikzpicture}[remember picture,overlay]
%    \node[anchor=north east,yshift=2pt] at (current page.north east) {\epsfig{file=puclogo_small_bw,width=1.2cm}};
%    \end{tikzpicture}}


%\addtobeamertemplate{frametitle}{}{%
    %\begin{tikzpicture}[node distance=0cm, remember picture, overlay, every node/.style={inner sep=0,outer sep=0, node distance=0cm, baseline=0cm}]
    %\node[anchor=north east] at (current page.north east) {\epsfig{file=puclogo_small_bw,width=1cm}};
    %\end{tikzpicture}}


%\logo{\includegraphics[height=0.8cm]{puclogo_small_bw.pdf}\vspace{220pt}}


\begin{frame}
   \frametitle{Sumário}
   \tableofcontents[pausesections]
\end{frame}

%\AtBeginSection[] % Do nothing for \section*
%{
%\begin{frame}<beamer>
%\frametitle{Outline}
%\tableofcontents[currentsection]
%\end{frame}}


\addtobeamertemplate{frametitle}{}{%
   \begin{textblock*}{10mm}(.9945\textwidth,-1.72cm)
		\includegraphics[height=0.97cm]{puc_engesoft_logo.png}%\includegraphics[height=1cm]{puclogo_small_bw.pdf}
   \end{textblock*}
}

\section{Interfaces}

\section{Fundamentos}

\subsection{Definição de interface}

\begin{frame}{Interface}
\begin{center}
``\textbf{Interface}: parte visível de um módulo a outros módulos. \\
A interface deve oferecer um grupo de métodos coerente. \\
Se uma interface é definida e sempre é mantida, o sistema ganha em extensibilidade e em baixo acoplamento.''
\end{center}
\end{frame}

\begin{frame}{Interfaces}
\begin{itemize}
\item \textbf{Interfaces}:
\begin{itemize}
    \item ``determinado conjunto de métodos que serão implementados em uma classe''.
    \item ``contrato que define tudo o que uma classe deve fazer se quiser ter um determinado status''.
\end{itemize}
\item Podemos, então, especificar uma interface; e uma ou mais classes ``assinariam este contrato'', comprometendo-se a implementar o que foi especificado.
\end{itemize}
\end{frame}


\subsection{Interfaces em Java}


\begin{frame}{Interfaces}
\begin{itemize}
\item Interfaces em Java possuem prioritariamente declarações de métodos (sem definição) e atributos ``\lstinline|public static final|''.
\item A implementação fica a cargo de cada especialização desta interface.
\item Interfaces são usadas para definir um protocolo de comportamento que pode ser implementado por qualquer classe na hierarquia de classes.
\item Interfaces podem ser declaradas, mas não podem ser instanciadas, assim como classes abstratas.
\item É uma saída elegante ao problema da herança múltipla.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Definindo uma interface}

\begin{itemize}
\item Definição de interfaces:
	\begin{itemize}
	\item Declaração da interface: declara os atributos tais como nome da interface e se ela herda de outra interface.
	\item Corpo da interface: contém as definições de constantes e  as declarações dos métodos da interface.
	\end{itemize}
\end{itemize}
\begin{lstlisting}
interface nomeInterface [extends OutraInterface] {
  corpo da Interface;
}
\end{lstlisting}
\begin{itemize}
\item Para se usar uma interface usa-se a palavra-chave \lstinline|implements|.
\end{itemize}
\end{frame}


\subsection{Exemplo: Timer e Wakeable}

\begin{frame}[fragile]{Exemplo: Temporizador e classes acordáveis}
\begin{itemize}
\item A classe Timer  é um serviço que notifica objetos acordáveis que um certo tempo passou.
\item Um objeto acordável deve fazer duas coisas:
	\begin{itemize}
	\item Pedir para o Timers acordá-lo após certo tempo.
	\item Implementar o método wakeUp.
    \end{itemize}
\item Método \texttt{letMeSleepFor} é implementado da seguinte forma:
\end{itemize}
\begin{lstlisting}
public synchronized boolean letMeSleepFor(Sleeper
                                theSleeper, long time) {
   int index = findNextSlot();
   if (index == NOROOM) {
       return false;
   } else {
       sleepers[index] = theSleeper;
       sleepFor[index] = time;
       new AlarmThread(index).start(); return true;
   }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Exemplo: Temporizador e classes acordáveis}
\begin{itemize}
\item Se o Timer tem espaço na lista, ele registra o dorminhoco e começa uma nova tarefa (thread) para este dorminhoco.
\item Um objeto que quiser usar o Timer deve implementar o método.
\item Como fazer um tipo genérico?
	\begin{itemize}
	\item O primeiro argumento de letMeSleepFor() é um objeto do tipo Wakeable (acordável).  Este tipo deve ser uma interface genérica para todos os tipos.
	\end{itemize}
\begin{lstlisting}
public interface Wakeable {
   public void wakeUp();
   public long ONE_SECOND = 1000;
   public long ONE_MINUTE = 60000;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exemplo: Temporizador e classes acordáveis}

\begin{itemize}
\item A interface Sleeper declara o método wakeUp() mas não a implementa. Ela também define constantes úteis.
\item As classes que implementarem esta interface ``herdam'' a constante e devem implementar o método wakeUp().
\item Todo objeto será também um dorminhoco.
\item Exemplo: um relógio que deve ser acordado a cada segundo para atualizar o display do tempo.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exemplo: Temporizador e classes acordáveis - UML}
    \begin{center}
    \begin{tikzpicture}
     \umlclass[font=\fontsize{7}{7}\selectfont,x=-5.5]{JFrame}{}{\umlvirt{+ paint(Graphics)}}

     \umlclass[font=\fontsize{7}{7}\selectfont,x=-2,type=interface]{Wakeable}%
      {\umlstatic{+ ONE\_SECOND = 1000} \\%
       \umlstatic{+ ONE\_MINUTE = 60000}}%
      {\umlvirt{+ wakeUp() : void}}

     \umlclass[font=\fontsize{7}{7}\selectfont,x=-3.2, y=-3]{GUIClock}%
     {}{+ wakeUp() \\ + paint(Graphics)}

     \umlclass[font=\fontsize{7}{7}\selectfont, x=2.5]{Timer}%
     {\umlstatic{-- MAX\_CAPACITY = 10} \\ \umlstatic{-- UNUSED = -1} \\ \umlstatic{-- NOROOM = -1} \\ -- wakeables : Wakeable[] \\ -- sleepFor : long[]}
     {+ letMeSleepFor(Wakeable, long) \\  + wakeUp(int)}
    \umlimpl{GUIClock}{Wakeable}
    \umlinherit{GUIClock}{JFrame}
    \umluniassoc{Timer}{Wakeable}
    \end{tikzpicture}
    \end{center}
\end{frame}


\section{Aspectos de projeto}

\subsection{Interfaces versus Classes Abstratas}

\begin{frame}[fragile]{Porque utilizar interfaces ao invés de classes abstratas?}
\begin{itemize}
\item Seria a classe abstrata Sleeper abaixo equivalente à interface?
\end{itemize}
\begin{lstlisting}
abstract class Wakeable {
   public abstract void wakeUp();
}
\end{lstlisting}
\begin{itemize}
\item Resposta: Não.
\item Se Sleeper fosse classe abstrata apenas objetos que herdassem de Sleeper poderiam ser utilizados no AlarmClock.
\end{itemize}
\end{frame}

\begin{frame}{Problemas com classe abstrata}
\begin{itemize}
\item Suponha o exemplo do relógio.
\item Se o relógio for um applet ele deve herdar da classe applet.
\item Como Java não permite herança múltipla não seria possível tornar o relógio um dorminhoco.
\end{itemize}
\end{frame}

\begin{frame}{Interfaces provêm Herança Múltipla?}
\begin{itemize}
\item Podem ser encarados como um paliativo, mas são coisas diferentes diferentes:
	\begin{itemize}
	\item Uma classe herda apenas constantes de uma interface.
	\item Uma classe não pode herdar implementações de uma interface.
	\item A hierarquia de interfaces é independente da hierarquia de classes. Classes que implementam a mesma interface podem ou não estar relacionadas na hierarquia.
	\end{itemize}
\item Java permite herança múltipla de interfaces.
\end{itemize}
\end{frame}

\begin{frame}{Para que usar Interfaces?}
\begin{itemize}
\item Use interfaces para definir protocolos de comportamento que possam ser implementados em qualquer lugar na hierarquia de classes.
\item Interfaces são úteis para:
	\begin{itemize}
	\item Capturar similaridades entre classes não relacionadas.
	\item Declarar métodos que uma ou mais classes devem inevitavelmente implementar.
	\item Revelar interfaces sem revelar os objetos que a implementam (útil na venda de pacotes de componentes).
	\end{itemize}
\end{itemize}
\end{frame}

\subsection{Métodos \textit{default}}


\begin{frame}{Métodos default}

\begin{itemize}
\item Até o Java 7, interface não podia prover nenhuma implementação.
\item No Java 8, um método \textit{default} permite definir um método de interface com implementação.
\item Permite expandir a interface sem violar o código existente.
\item Permite implementar métodos que são opcionais, dependendo da forma como a interface é usada.
\item Pode produzir erro de herança múltipla de método.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Métodos default}

\begin{multicols}{2}
\begin{lstlisting}
public interface IFace {
  // decl. método normal
  int getUserID();
  // decl. método default
  default int getAdminID() {
   return 1;
  }
}
\end{lstlisting}

\begin{lstlisting}
class IFaceImpl implements IFace {
  public int getUserID() {
    return 100;
  }
}
\end{lstlisting}
\end{multicols}

\begin{lstlisting}
class Demo {
  public static void main(String args[]) {
    IFaceImpl obj = new IFaceImpl();

    System.out.println("User ID is " + obj.getUserID());
    System.out.println("Administrator ID is " + obj.getAdminID());
  }
}

\end{lstlisting}\footnote{Adaptado de: Herbert Schildt. \textit{Java Para Iniciantes.} Bookman 2015.}
\end{frame}

\begin{frame}[fragile]{Métodos default}

\begin{lstlisting}

public interface Ordenavel {

   boolean menorQue(Ordenavel o);

   boolean igual(Ordenavel o);

   default boolean diferente(Ordenavel o) {
      return !igual(o);
   }

   default boolean maiorQue(Ordenavel o) {
      return !menorQue(o) && !igual(o);
   }

}
\end{lstlisting}
\end{frame}

\subsection{Expressões Lambda e interfaces funcionais}

\begin{frame}{Expressões Lambda e interfaces funcionais}

    \begin{itemize}
        \item Espressões lambda e interfaces funcionais são elementos da programação funcional incorporados ao Java.
        \item Programação funcional, com sua ênfase em funções "puras", tratadas como valores de 1a classe (que retornam o mesmo resultado dadas as mesmas entradas, sem a produção de efeitos colaterais) e a imutabilidade simplificam a programação paralela.
    \end{itemize}

    \begin{block}{Interfaces funcionais  (\textit{functional interface})}
       são interfaces com um único método abstrato. Sua implementação pode ser feita por uma classe regular, classe interna, classe anônima ou expressão lambda.
    \end{block}
\end{frame}



\begin{frame}[fragile]{Expressões Lambda e interfaces funcionais}
    \begin{enumerate}
        \item Considere a interface \lstinline|Comparator<T>|, disponível no Java.
        \item Ela é uma \textit{functional interface} baseada no método \lstinline|compare|, e pode ser implementada por uma expressão lambda ou referência de método.
        \item Ela possui inúmeros métodos default e outros métodos que já são implementados a paritr da classe \lstinline|Object|.
    \end{enumerate}

\begin{block}{}
    \begin{lstlisting}
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);

    ...
}
    \end{lstlisting}
\end{block}
\end{frame}



\begin{frame}[fragile]{Interfaces funcionais com classes internas}

    \begin{enumerate}
        \item Considere a necessidade de se ordenar o estoque de produtos pela quantidade disponível.
        \item Sulução possível: classe \lstinline|OrdenarPorQuantidade| implementa a interface \lstinline|Comparator<T>|.
    \end{enumerate}

    \begin{block}{}
        \begin{lstlisting}
private class OrdenarPorQuantidade implements Comparator<Produto> {

    @Override
    public int compare(Produto o1, Produto o2) {
        return Integer.compare(o1.getQuantidade(), o2.getQuantidade());
    }
}

public void ordenarPorQuantidade() {
    Arrays.sort(produtos, 0, numProdutos, new OrdenarPorQuantidade());
}
        \end{lstlisting}
    \end{block}
\end{frame}




\begin{frame}[fragile]{Interfaces funcionais com classes anônimas}

    \begin{enumerate}
        \item Considere a necessidade de se ordenar o estoque de produtos pela Data de Fabricação.
        \item Sulução possível: classe interna anônima que implementa a interface \lstinline|Comparator<T>|.
    \end{enumerate}

    \begin{block}{}
        \begin{lstlisting}
public void ordenarPorFabricacao() {
   Arrays.sort(produtos, 0, numProdutos, new Comparator<Produto>() {
      @Override
      public int compare(Produto o1, Produto o2) {
         return o1.getDataFabricacao().compareTo(o2.getDataFabricacao());
      }
   });
}
        \end{lstlisting}
    \end{block}
\end{frame}


\begin{frame}[fragile]{Interfaces funcionais com expressões lambda}

    \begin{enumerate}
        \item Considere a necessidade de se ordenar o estoque de produtos pelo preço.
        \item Sulução possível: expressão lambda que implementa a interface \lstinline|Comparator<T>|.
    \end{enumerate}

    \begin{block}{}
        \begin{lstlisting}
public void ordenarPorPreco() {
   Arrays.sort(produtos, 0, numProdutos, (o1, o2) -> Float.compare(o1.getPreco(), o2.getPreco()));
}
        \end{lstlisting}
    \end{block}
\end{frame}




\end{document}
